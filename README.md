# auth-proxy -  Пользовательская авторизация



## Мотивация

**Контроль доступа к данным**.

В **редакции онлайн газеты** есть несколько отделов: новости, спорт, политика, технологии, литературная жизнь т.п.. 

Наша **задача** создать **web приложение для литературного отдела**.  (API  и HTML). 






![alt_text](templates/images/Sketches-1.png "users and roles")

**Пользователи** приложения делятся на несколько  категорий, с каждой из которых сопоставлена определенная **роль**. Авторы пишут статьи, редакторы правят их, шефы решают, какие материалы будут опубликованы, читатели не пишут статей, но могут оставлять комментарии . Один и тот же **пользователь может выполнять несколько ролей**.

Учет пользователей, ролей, аутентификация,  авторизация (наделение пользователей ролями, и тем самым делегация им определенными прав) составляет значительную часть приложения.

В настоящей редакции могут быть десятки таких приложений. Легко представить, как **возрастает сложность** контроля доступа в редакции с ростом числа приложений, ролей и пользователей. 


## Борьба со сложностью

Идея -  вынести функции защиты в отдельное приложение **auth-proxy**.


![alt_text](templates/images/Sketches-0.png "image_tooltip")


**Auth- proxy** избавляет приложения от задач контроля доступа, уменьшает код приложений, объемы и сложность данных с которыми они работают, не говоря уже о регламентах администрирования и прочих бизнес правилах.

Клиентами **auth-proxy** могут выступать не только пользователи, но и другие приложения.


## Как работает auth-proxy






![alt_text](templates/images/Sketches-3.png "image_tooltip")


Сначала клиент посылает **auth-proxy** имя и пароль и в случае успешной аутентификации получает в ответ **токен**  сгенерированный специально для данного клиента.  



    Токен служит временным удостоверением для клиента  на текущий сеанс связи. Клиент обязан присоединять его к заголовку каждого последующего запроса. Получая валидный токен сервер может быть уверен в том, что запрос пришел от аутентифицированного пользователя. 

Аuth-proxy присоединяет к заголовку запроса список ролей клиента в целевом приложении и пересылает запрос приложению.

После получения ответа приложения auth-proxy пересылает ответ обратно клиенту.

В целом схема похожа на контроль гостей на мероприятиях. При входе приглашенный называет фамилию и имя, и если он есть в списке ему выдается браслет (баджик/токен), который он должен предъявлять всякий раз, когда решит временно отлучиться.




## Разделение ответственности

**Auth-proxy  отвечает, за:**



1. Аутентификацию (идентификацию) пользователей - удостоверение в том, что пользователь именно тот за кого себя выдает. Производится с помощью имени/пароля и web - токенов.
2. Авторизацию (делегирование прав) - определение списка ролей пользователя для каждого конкретного приложения.
3. Проксирование — пересылка запросов пользователя конечному приложению и обратно. 
4. Создание, редактирование, удаление записей о пользователях, ролях и приложениях.

С академической точки зрения,  auth-proxy нужно бы разделить на 4 отдельных приложения, по одному на задачу,  но из практических соображений они были объединены в одно.

**Конечное приложение отвечает за:**



1. За обработку запросов пользователя с учетом его ролей, перечисленных в заголовке запроса.


## Модель данных

Ядром авторизации служит таблица **app_user_role**, с полями **usernamе, appname, rolename** для хранения идентификатора пользователя, приложения и его роли в этом приложении. Пользователь может выполнять несколько ролей в конкретном приложении. В этом случае под каждую роль в таблице заводится отдельная запись.



![alt_text](templates/images/Sketches-4.png "db schema")


Кроме главной таблицы **app_user_role** должны быть три справочные таблицы  user, app и role, для хранения дополнительных сведений о пользователях, приложениях и ролях. На самом деле их две: **user** и **app**.

Справочная таблица role отсутствует потому, что ответственность за  набор конкретных привилегий, связанных с ролью, лежит на конечном приложении, и auth-proxy не обязано о них знать.  Для auth-proxy роль - это ничего не значащий идентификатор.


![alt_text](templates/images/Sketches-5.png "image_tooltip")

Таблица `user` используется для аутентификации пользователя , где кроме идентификатора хранится хэш пароля. Сам пароль не сохраняется из соображений секретности.

Таблица `app` используется для проксирования запросов к конечным приложениям и помимо прочего содержит IP адрес конечного приложения, возможно недоступный с компьютера клиента.


## Токены

Токены выдаются успешно аутентифицированному клиенту и работают по схеме web-токенов (jwt). Токен состоит из тела, подписанного цифровой подписью, сгенерированной Auth-proxy c с помощью секретного ключа. Получив от клиента токен сервер проверяет соответствие подписи телу токена с помощью того же ключа. Таким образом происходит проверка токена на подлинность. Если клиентом auth-proxy является веб - приложение, токен сохраняется на компьютере клиента как куки браузера.


## Администрирование пользователей и приложений

**authadmin** - единственная роль определенная в  приложении auth-proxy.

Пользователь с такой ролью имеет максимальные права и может добавлять приложения, назначать роли пользователям и т.п., и может полностью переконфигурировать систему. 

Остальные пользователи могут только



*   просматривать список конечных приложений
*   делать запросы к конечным приложениям 
*   и изменять свои личные данные.


### Замечания

Рекомендуется иметь хотя бы двух пользователей с ролью **authadmin** на случай если один, по ошибке заблокирует, лишит себя этой роли или даже удалит о себе запись.

Вопрос о привилегиях authadmin остается открытым для обсуждения. Возможно имеет смысл запретить ему удаление пользователей, или запретить модификацию записей других пользователей с ролью authadmin, или запретить самоудаление/самоблокирование/саморазроливание.


## Флаги приложений

Каждая запись в таблице app имеет поля `public` и `rebase`.

- `public` Установите в "Y" чтобы сделать приложение доступным для пользователей без роли. В списке приложений пользователь может видеть только те, в которых у него определена роль и приложения с `public=Y`. Другие приложения недоступны пользователю, как для перечислений в списках поиска, так и для проксирования.

- `rebase` 
    Поле имеет смысл только для проксирования HTML web приложений.

    Если значение поля равно "Y" приложение пытается "подправить" ссылки, изображения, фреймы в HTML и CSS так, чтобы URI начинающиеся с /, начинались с /apps/appname/. Это делается для того, чтобы браузер не запрашивал ресурсы там, где их нет, то есть в корне auth-proxy.

    Эта операция влечет за собой увеличение потребления памяти и загрузки процессора сервера. Поэтому в приложениях предназначенных для проксирования рекомендуется использовать относительные ссылки и оставлять это поле пустым.


## Параметры командной строки приложения

Приложение запущенное без параметров выдает список возможных параметров и завершается. 



__Приложение в Интернет__

http://auth-proxy.rg.ru/

__Схема__

http://auth-proxy.rg.ru/graphql

__Тестовое GUI приложение__

http://auth-proxy.rg.ru/testapp






----------------------------------------------------------


Информация для разработчиков
============================



Локальные адреса


- Тестовая страница API: <http://localhost:4400/> `GET`.

- Конечная точка GraphQL <http://localhost:4400/schema> `POST`.

- Тестовое приложение <http://localhost:4400/testapp> `GET`.


Запуск приложения 
-----------------

Для хранения данных приложение использует Postgres или SQLite. Для запуска приложения с использованием SQLite выполните 

    go run main.go -serve 4400 -env=dev -sqlite


Запуск Postgres
-----------------------   
Для Postgres  запуском приложения нужно запустить Postgres

    docker-compose up -d    

Затем запустить приложение командой
    
    go run main.go -serve 4400 -env=dev


Для просмотра списка возможных параметров запустите программу без параметров.

    go run main.go



## Миграции

**Важно!** При запуске программы запускаются миграции => вся работа с базой данных должна проходить с помощью [миграций](https://github.com/golang-migrate/migrate). Файлы находятся в директории `migrations/`.

**Create**  

    migrate create -ext sql -seq -digits 2 -dir migrations name


**Up, Down, Version, Goto...**  

    migrate -source=file://migrations/ -database postgres://root:root@localhost:5432/auth?sslmode=disable up 
    migrate -source=file://migrations/ -database postgres://root:root@localhost:5432/auth?sslmode=disable down
    migrate -source=file://migrations/ -database postgres://root:root@localhost:5432/auth?sslmode=disable version
    migrate -source=file://migrations/ -database postgres://root:root@localhost:5432/auth?sslmode=disable goto 2



Тесты
--------

Запуск всех тестов

    go test -v ./...


Функциональные тесты (End to End) проводятся с помощью <https://graphql-test.now.sh/>


Бенчмарки соединений с БД с пулом и без
--------------------------------------

    go test -run=Bench -benchmem -benchtime=1s -bench=. ./pkg/db

результаты

    Benchmark_local_DB-4           500     3210246 ns/op    18911 B/op     303 allocs/op
    Benchmark_local_DB_pool-4    10000      221768 ns/op     1181 B/op      28 allocs/op
    Benchmark_remote_DB-4          200     7894973 ns/op    22676 B/op     312 allocs/op
    Benchmark_remote_DB_pool-4   10000      210710 ns/op     1181 B/op      28 allocs/op
    Benchmark_SQLite-4           10000      114440 ns/op     4328 B/op      89 allocs/op
    Benchmark_SQLite_pool-4      10000      209662 ns/op     1511 B/op      29 allocs/op

оптимизация `getKeysAndValues()`

    Benchmark_getKeysAndValues-4              500000              2947 ns/op             848 B/op         28 allocs/op
    Benchmark_getKeysAndValues1-4            1000000               853 ns/op             400 B/op         11 allocs/op



Сборка для фронтэнд разработчиков
----------------------------------------------


    sh/build-frontend-container-bare.sh

или 

    sh/build-frontend-container.sh



О программе
=====================

Данные
-------


<img src="templates/images/Sketches-5.png">

Таблицы БД восстанавливаются и наполняются тестовыми данными при каждом запуске приложения. Тестовые данные помечены словом test, так что их легко идентифицировать и удалить.

Для обеспечения ссылочной целостности на таблицы наложены ограничения внешних ключей с каскадным удалением из подчиненных таблиц. На ключи построены индексы.




Файлы и директории
-------------------



    configs/

Содержит настроечные файлы соединений с Postgres и SQLite. 


    server/

Сопоставляет маршруты функциям-контроллерам, присоединяет middleware, и запускает сервер,
содержит функции GraphQL и REST API.
Каждый запрос к программе обрабатывается двумя функциями middleware до того как будет обработан основным контроллером. `CheckUser()` проверяет токен запроса, залогинен ли пользователь.

```
Жизненный цикл запроса

(req) --> HeadersMiddleware --> CheckUser --> router --> controller --> (resp)
```
`HeadersMiddleware` добавляет CORS заголовки.  `CheckUser` проверяет залогинен ли пользователь и добавляет к запросу заголовки с информацией о пользователе и его ролях перед перенаправлением запроса конечному  приложению.




    pkg/
        db/             - база данных
        auth/           - работа с пользователями
        mail/           - почта
        session/        - работа с сессиями
        primitiveproxy  - функция проксирования запросов 




    migrations/
        

SQL скрипты для порождения объектов базы данных. Миграции исполняются  при каждом запуске программы, поэтому программа будет корректно работать даже при изначально пустой базе данных.



**Второстепенные файлы**


    etc/
        .pgpass

Файл используется контейнером db Postgres, чтобы не вводить пароли при дампе и восстановлении базы данных.


    templates/


Шаблоны приветственного сообщения приложения и тестовой страницы API <http://localhost:4400/>.





    docker-compose.yml     
    main.go
    README.md                           # Этот файл
    build-frontend-container.sh*        # Скрипт сборки докер контейнера для фронтэнд разработчиков
    build-frontend-container-bare.sh*   # Скрипт сборки докер контейнера для фронтэнд разработчиков
    Dockerfile-frontend                 # Используется в build-frontend-container.sh
    Dockerfile-frontend-bare            # Используется в build-frontend-container.sh
    docker-compose-frontend.yml         # Файл запуска для фронтэнд разработчиков. 
    docker-compose-frontend-bare.yml    # Файл запуска для фронтэнд разработчиков. 
    TODO.md                             # Недоделки








-------------------------------------------------------

Другие команды
--------------------


Просмотр состояния базы данных


Postgres доступен на localhost:5432.

Если блок adminer раскомментирован в `docker-compose.yml`, то в браузере откройте <http://localhost:8080>. 

Параметры доступа:
- System: PostgreSQL,
- Server: db,
- Username: root,
- Password: root,
- Database: auth




Останов базы данных
    
    docker-compose down



Удаление файлов базы данных после останова docker-compose

    sudo rm -rf  pgdata



Дамп базы данных в файл в директорию `migrations/`.
  
    docker exec -it psql-com pg_dump --file /dumps/auth-dump.sql --host "localhost" --port "5432" --username "root"  --verbose --format=p --create --clean --if-exists --dbname "auth"


Восстановление БД из дампа в `migrations/`.

    docker exec -it psql-com psql -U root -1 -d auth -f /dumps/auth-dump.sql



Дамп схемы БД

    docker exec -it psql-com pg_dump --file /dumps/auth-schema.sql --host "localhost" --port "5432" --username "root" --schema-only  --verbose --format=p --create --clean --if-exists --dbname "auth"


Дамп только данных таблиц.

    docker exec -it psql-com pg_dump --file /dumps/auth-data.sql --host "localhost" --port "5432" --username "root"  --verbose --format=p --dbname "auth" --column-inserts --data-only --table=broadcast --table=post --table=image


Можно добавить  -$(date +"-%Y-%m-%d--%H-%M-%S") к имени файла для приклеивания штампа даты-времени.



Показ структуры таблицы TABLE_NAME

    docker-compose exec db pg_dump -U root -d auth -t TABLE_NAME --schema-only



Командная строка Postgres

	docker-compose exec db psql -U root auth



Командная строка Redis

    docker-compose exec redis redis-cli



## контроль деплоя на works

    ssh -i ~/.ssh/deploy_gitupdater_works_open_ssh gitupdater@212.69.111.246

    sudo docker network ls
    sudo docker exec -it auth-proxy-prod bash
    sudo docker logs -f auth-proxy-prod
    sudo docker logs -f auth-node







